<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <title>Editor | Pragmatic Hybrid Entity Component System</title>
  <meta name="description" content="PH-ECSの統合エディタ構造とUIデザイン。リアルタイム操作と即時反映を可能にするランタイム一体型エディタ。">
  <link rel="stylesheet" href="CSS/styles.css">
</head>
<body>

  <aside class="sidebar">
  <h2>ページナビゲーション</h2>
  <ul>
    <li><a href="#overview">Editor Overview</a></li>
    <li><a href="#core-windows">Editor Windows</a></li>
    <li><a href="#navigation">Next Pages</a></li>
  </ul>

  <h2>他ページ</h2>
  <ul>
    <li><a href="index.html">Top</a></li>
    <li><a href="architecture.html">Architecture</a></li>
    <li><a href="support.html">Support</a></li>
    <li><a href="developer.html">Developer</a></li>
  </ul>
</aside>

<header class="hero">
  <h1>Editor</h1>
  <p class="subtitle">ランタイム統合型エディタのビジュアルデザインと構造</p>
</header>

<section id="overview" class="section">
  <h2>Editor Overview</h2>
  <p>
    PH-ECSのエディタは独立したアプリケーションではなく、<strong>Runtimeに統合されたインタラクティブUI</strong>として動作します。  
    これにより、ゲーム実行中でもEntity・Component・Systemをリアルタイムに編集・反映できます。
  </p>
  <p>
    <strong><a href="https://github.com/ocornut/imgui">ImGui</a></strong>をベースとした即時モードUIを採用し、軽量かつ高応答なエディタ操作を実現しています。
  </p>

  <figure class="diagram">
    <img src="Image/Editor.png" alt="Editor Layout Diagram">
    <figcaption>図1. ランタイム統合型エディタ構成</figcaption>
  </figure>
</section>

<section id="core-windows" class="section highlight">
  <h2>Editor Windows</h2>
  <p>
    各ウィンドウは独立したモジュールとして構築され、エンジン内部のデータと双方向に通信します。  
    UIは統一されたテーマとアニメーションで構成され、操作感の一貫性を重視しています。
  </p>

  <div class="window-grid">
    <div class="window-card">
      <h3>🎮 GameViewWindow</h3>
      <p>
        実際のゲーム画面をプレビュー。エディタのサイズ変更に追従しつつ、  
        固定アスペクト比を維持します。  
        <strong>Scene View</strong>と同期しており、プレイヤー視点やカメラ切替をリアルタイムで反映可能です。

      </p>
    </div>
<pre><code class="language-cpp">
// --- 抜粋: Game Viewport Window --- 
                                                ・
                                                ・
                                                ・

    auto windowContentSize      { ImGui::GetContentRegionAvail() };
    auto gameScreenOriginalSize { ImVec2{ static_cast&lt;float&gt;m_windowW, static_cast&lt;float&gt;m_windowH } };
    auto aspectRatio            { gameScreenOriginalSize.x / gameScreenOriginalSize.y };
    auto scaledWidth            { windowContentSize.x };
    auto scaledHeight           { scaledWidth / aspectRatio };

    if (scaledHeight &gt; windowContentSize.y)
    {
        scaledHeight = windowContentSize.y;
        scaledWidth  = scaledHeight * aspectRatio;
    }

    auto offset { ImVec2{
        (windowContentSize.x - scaledWidth)  * Def::Half,
        (windowContentSize.y - scaledHeight) * Def::Half
    } };

    ImGui::SetCursorPos(ImGui::GetCursorPos() + offset);
    ImGui::Image(texId, ImVec2{ scaledWidth, scaledHeight });
}
</code></pre>

<div class="concept-block">
  <h4>📐 技術的ポイント</h4>
  <ul>
    <li>ウィンドウのリサイズに応じて動的にスケーリングを行い、<strong>アスペクト比を厳密に保持</strong>。</li>
    <li><code>ImGui::GetContentRegionAvail()</code> と <code>ImGui::SetCursorPos()</code> を用いて、中心補正による美しいレイアウトを実現。</li>
  </ul>
</div>

    <div class="window-card">
      <h3>📦 AssetsWindow</h3>
      <p>
        アセットブラウザ。<strong>Tree表示</strong>と<strong>Current表示</strong>の2モードを搭載。  
        ドラッグ＆ドロップ、右クリックメニュー、外部ファイルの取り込みにも対応。  
        拡張子に応じたプレビューアイコンを自動表示します。
      </p>
    </div>

    <pre><code class="language-cpp">
// --- 抜粋: FlFileEditor::ShowAssetBrowser ---
if (ImGui::Begin(title.c_str(), p_open, flags))
{
    if (ImGui::BeginTabBar("ControlTabs"))
    {
        if (ImGui::BeginTabItem("Current"))
        {
            RenderCurrentItem();
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Tree"))
        {
            FileEntry root{};
            BuildFileTree(m_basePath, root);
            RenderFileEntry(root);
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }

    // 外部ファイルドロップ受付
    if (!m_doppedPath.empty())
    {
        auto entryPath{ m_currentPath };

        auto dst{ entryPath / m_doppedPath.filename() };
        if (std::filesystem::exists(dst))
        {
            auto count{ Def::IntZero };
            auto stem{ dst.stem().string() };
            auto ext{ dst.extension().string() };
            do {
                dst = entryPath / (stem + "_copy" + std::to_string(++count) + ext);
            } while (std::filesystem::exists(dst));
        }

        // ログ出力
        if (m_fileWatcher.Copy(m_doppedPath, dst))
        {
            auto dopp{ m_upFPM->GetRelative(m_doppedPath) };
            FlEditorAdministrator::Instance().GetLogger()->AddChangeLog("Dropped External File: %s to %s", dopp.string().c_str(), dst.string().c_str());
        }
        else
        {
            auto dopp{ m_upFPM->GetRelative(m_doppedPath) };
            FlEditorAdministrator::Instance().GetLogger()->AddErrorLog("Error: Dropped External File: %s to %s", dopp.string().c_str(), dst.string().c_str());
        }

        m_doppedPath.clear();
    }

    RenderPopup();
}
ImGui::End();
</code></pre>

<div class="concept-block">
  <h4>🧭 技術的ポイント</h4>
  <ul>
    <li><code>std::filesystem</code> を用いて動的にディレクトリツリーを構築し、ファイル構造の変更を即時反映。</li>
    <li>外部ファイルのドラッグ＆ドロップ(D&D)を検知し、同名衝突時には <strong>自動で "_copy[n]" 連番処理</strong>を行う安全設計。</li>
    <li>ImGuiのポップアップメニュー（右クリック）を活用して、<strong>エクスプローラ連携・クリエイト・リネーム・コピー(GUIDもしくはパス)・ペースト・削除</strong>などをワンクリックで操作可能。</li>
  </ul>
</div>

<pre><code class="language-cpp">
// --- 抜粋: FlFileEditor::RenderFileEntry ---
if (ImGui::BeginPopupContextItem())
{
    if (ImGui::MenuItem("Open")) 
    {
        ShellExecuteW(nullptr, L"open", L"explorer.exe", entry.path.wstring().c_str(), nullptr, SW_SHOWNORMAL);

        // ログ出力
        FlEditorAdministrator::Instance().GetLogger()->AddLog("Open %s",
            entry.path.string().c_str());
    }
                      ・
                      ・
                      ・
    if (ImGui::MenuItem("Copy Guid"))
    {
        auto guid { FlResourceAdministrator::Instance()
                        .GetMetaFileManager()->FindGuidByAsset(entry.path) };
        if (!guid.has_value())
            // ログ出力
            FlEditorAdministrator::Instance().GetLogger()->AddErrorLog("Failed Copy Guid by %s",
                entry.path.string().c_str());
        else
        {
            ImGui::SetClipboardText(guid.value().c_str());

            // ログ出力
            FlEditorAdministrator::Instance().GetLogger()->AddLog("Copy Guid by %s",
                entry.path.string().c_str());
        }
    }
                      ・
                      ・
                      ・
    if (ImGui::MenuItem("Delete"))
        m_pendingPopup = PopupRequest{ entry.path, PopupRequest::Type::Delete };
    ImGui::EndPopup();
}
</code></pre>

<div class="concept-block">
  <h4>📂 技術的ポイント</h4>
  <ul>
    <li><strong>右クリックメニュー</strong>はImGuiの <code>BeginPopupContextItem()</code> を利用して即時生成し、コード量を分割化。
        <br>そして、警告文やキャンセルなどの選択肢を出し誤操作を回避します。</li>
    <li>各ファイル・ディレクトリに対し、<strong>GUIDメタ情報を関連付け</strong>て一貫したアセット管理を実現。</li>
    <li>メタファイル追従（リネーム・移動検知）は <code>FlResourceAdministrator</code> 経由で処理され、GUID再発行を防止。</li>
  </ul>
</div>

    <div class="window-card">
      <h3>📘 ListingViewer</h3>
      <p>
        GUIDとアセットパスの対応関係を一覧化するツール。  
        <strong>Filter検索</strong>で瞬時に目的のアセットを特定でき、  
        表示モード切替により <strong>GUID / Assets / 両方</strong> のビューを自在に切り替え可能。  
        MetaFileManagerの内部マップをリアルタイムに反映します。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlListingEditor::RenderListingViewer ---
ImGui::Begin(title.c_str(), p_open, flags);

m_filter.Draw("Filter (type to search)", 200.0f);
ImGui::SameLine();
if (ImGui::Button("Option")) m_isOption = !m_isOption;
ImGui::Separator();

if (m_isOption)
{
    bool checked1{ (m_listingTypes & GuidAndAssets) == GuidAndAssets }; 
    if (ImGui::Checkbox("GuidAndAssets", &checked1))
    {
        if (checked1) m_listingTypes |= GuidAndAssets;
        else m_listingTypes &= ~GuidAndAssets;
    }
    bool checked2{ (m_listingTypes & Guid) != None };
    if (ImGui::Checkbox("Guid Only", &checked2))
    {
        if (checked2) m_listingTypes |= Guid;
        else m_listingTypes &= ~Guid;
    }
    bool checked3{ (m_listingTypes & Assets) != None };
    if (ImGui::Checkbox("Assets Only", &checked3))
    {
        if (checked3) m_listingTypes |= Assets;
        else m_listingTypes &= ~Assets;
    }
}
else
{
    ListingGuidAssets(
        (m_listingTypes & GuidAndAssets),
        (m_listingTypes & Guid),
        (m_listingTypes & Assets)
    );
}

ImGui::End();
</code></pre>

<pre><code class="language-cpp">
// --- 抜粋: FlListingEditor::ListingGuidAssets ---
if (isAssetsAndGuid)
{
    if (ImGui::BeginTable("MapTable", 2,
        ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable))
    {
        ImGui::TableSetupColumn("Key");
        ImGui::TableSetupColumn("Value");
        ImGui::TableHeadersRow();

        for (const auto& [key, value] : guidMap)
        {
            std::string combined = key + " " + value;
            if (!m_filter.PassFilter(combined.c_str())) continue;

            ImGui::TableNextRow();
            ImGui::TableSetColumnIndex(0);
            ImGui::TextUnformatted(key.c_str());
            ImGui::TableSetColumnIndex(1);
            ImGui::TextUnformatted(value.c_str());
        }
        ImGui::EndTable();
    }
}
</code></pre>

<div class="concept-block">
  <h4>📘 技術的ポイント</h4>
  <ul>
    <li>
      <strong>MetaFileManager</strong> 内のGUIDマップを直接参照し、  
      <code>std::unordered_map&lt;std::string, std::string&gt;</code> 形式で即時描画。  
      更新があれば即座に反映されるリアルタイム設計。
    </li>
    <li>
      <strong>ImGui::BeginTable()</strong> による高可読なテーブルUI。  
      <code>ImGuiTableFlags_Borders | RowBg | Resizable</code> を使用し、  
      大量データでも見やすく、列サイズ調整も可能。
    </li>
    <li>
      <strong>モード切替設計:</strong>  
      GUID／Asset／両方の表示を <code>BitFlag</code> で制御。  
      <code>GuidAndAssets</code>・<code>Guid</code>・<code>Assets</code> の3状態を  
      チェックボックスで直感的にトグル操作。
    </li>
    <li>
      <strong>柔軟なフィルタ条件ロジック:</strong>  
      複合条件（GUID＋Asset）検索にも対応するよう、  
      行結合文字列 <code>key + " " + value</code> で全文検索を実現。
    </li>
    <li>
      <strong>Option UI</strong> はトグル可能。  
      非表示時はコンパクトなリストビューとして機能し、  
      表示時はフィルタ設定やリストタイプ選択が可能な拡張モードに。
    </li>
  </ul>
</div>

    <div class="window-card">
      <h3>📜 ScriptEditor</h3>
      <p>
        C++スクリプトモジュールの作成・削除をGUI上で行うエディタ。  
        <strong>自動追加システム</strong>の<code>FlAutomaticFileAddSystem</code>を利用して、  
        <code>.vcxproj</code> および <code>.filters</code> ファイルを自動更新し、  
        新しいクラスをVisual Studioプロジェクトに即座に登録します。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlScriptEditor::Render --- 
if (ImGui::Begin(title.c_str(), p_open))
{
    if (ImGui::Button("Refresh"))
        RefreshFileList();

    ImGui::Separator();
    DrawFileList();

    if (ImGui::BeginPopup("ScriptContextMenu"))
    {
        if (ImGui::MenuItem("Create Script"))
            m_pendingPopup = PopupRequest{ PopupRequest::Type::Create };
        ImGui::EndPopup();
    }

    RenderPopup(); // Create / Delete popup を処理
}
ImGui::End();
</code></pre>

<pre><code class="language-cpp">
// --- 抜粋: FlScriptEditor::RenderPopup --- 
if (ImGui::BeginPopup("CreateScriptPopup"))
{
    ImGui::InputText("Class Name", &m_newClassName);
    ImGui::InputText("Filter Name", &m_filterName);

    if (ImGui::Button("Create") && !m_newClassName.empty())
    {
        if (m_autoAdd.CreateAndAdd(m_newClassName, m_filterName))
        {
            FlEditorAdministrator::Instance().GetLogger()->AddLog(
                "Script created: %s", m_newClassName.c_str());
            RefreshFileList();
        }
    }
    ImGui::EndPopup();
}
</code></pre>

<div class="concept-block">
  <h4>📜 技術的ポイント</h4>
  <ul>
    <li>
      <strong>XMLパーサと自動追加システム:</strong>  
      <code>FlAutomaticFileAddSystem</code> クラスを通じて  
      <code>FlComponentSystem.vcxproj</code> と <code>.filters</code> を  
      <strong>XML解析・編集</strong>し、新規クラス追加時に自動反映。  
      外部IDE操作を必要とせず、エディタ内で完結。
    </li>
    <li>
      <strong>ImGuiポップアップ設計:</strong>  
      「Create」「Delete」ポップアップを <code>PopupRequest</code> 構造体で一元管理。  
      ユーザー操作を逐次的にハンドリングし、状態遷移を簡潔化。
    </li>
    <li>
      <strong>ファイル監視と自動更新:</strong>  
      <code>std::filesystem</code> により  
      <code>DynamicLib/FlComponentSystem/Src/ComponentSystem</code> ディレクトリをスキャン。  
      ヘッダ／ソース (.h/.cpp) の追加・削除を即時反映。
    </li>
    <li>
      <strong>Visual Studioとの親和性:</strong>  
      エディタから生成されたスクリプトは  
      .vcxproj と .filters 双方に登録済みのため、  
      Visual Studioで即コンパイル可能。
    </li>
  </ul>
</div>

    <div class="window-card">
      <h3>🧩 Hierarchy</h3>
      <p>
        シーン内のEntityを階層表示。  
        D&Dで親子関係を変更でき、右クリックメニューでPrefab作成・インスタンス化が可能。  
        Sceneの保存・読込ボタンで即座にJSONファイルとして管理します。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlInspectorAndHierarchyEditor::RenderHierarchy ---
if (ImGui::Begin(title.c_str(), p_open, flags))
{
    if (ImGui::Button("Add Entity"))
        scene.CreateEntity(scene.GetRootEntity());

    if (ImGui::Button("Load Scene")) {
        std::string filepath = "Assets/Scene/";
        if (OpenFileDialog(filepath, "Load Scene",
            "Scene Files (*.scene)\0*.scene\0All Files (*.*)\0*.*\0")) {
            scene.LodeScene(filepath);
        }
    }

    if (ImGui::Button("Save Scene")) {
        std::string filepath = "Assets/Scene/";
        if (SaveFileDialog(filepath, "Save Scene",
            "Scene Files (*.scene)\0*.scene\0All Files (*.*)\0*.*\0", "scene")) {
            scene.SaveScene(filepath);
        }
    }

    if (ImGui::TreeNodeEx("Root", ImGuiTreeNodeFlags_DefaultOpen))
    {
        for (auto& child : scene.GetRootEntity()->children)
            if (auto sp = child.lock()) RenderEntityRecursive(sp);
        ImGui::TreePop();
    }
}
ImGui::End();
</code></pre>

<div class="concept-block">
  <h4>🌳 技術的ポイント</h4>
  <ul>
    <li>ルートEntityを起点に、<strong>再帰的に子Entityをツリー構造として描画</strong>。</li>
    <li>右クリックメニューから、Entityの生成・Prefab作成・削除・リネームを行える。</li>
    <li>Scene保存／読込はファイルダイアログを通じて即時反映。</li>
  </ul>
</div>

<pre><code class="language-cpp">
// --- 抜粋: FlInspectorAndHierarchyEditor::RenderEntityRecursive ---
bool nodeOpen = ImGui::TreeNodeEx(
    (void*)(intptr_t)spEnt->id,
    flags,
    "%s", spEnt->name.c_str()
);

// クリックで選択
if (ImGui::IsItemClicked(0) || ImGui::IsItemClicked(1))
    m_selectedEntity = spEnt;

// Drag & Drop による階層変更
if (ImGui::BeginDragDropSource())
{
    ImGui::SetDragDropPayload("ENTITY_DRAG", &spEnt->id, sizeof(int));
    ImGui::Text("Dragging Entity %d", spEnt->id);
    ImGui::EndDragDropSource();
}

if (ImGui::BeginDragDropTarget())
{
    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("ENTITY_DRAG"))
    {
        int draggedId = *static_cast<int*>(payload->Data);
        auto draggedEntity = FlScene::Instance().GetEntityById(draggedId).lock();
        if (draggedEntity && draggedEntity != spEnt)
        {
            // 親子関係の再構築処理
            ...
        }
    }
    ImGui::EndDragDropTarget();
}
</code></pre>

<div class="concept-block">
  <h4>🪄 技術的ポイント</h4>
  <ul>
    <li>ImGuiのDrag & Dropシステムを活用し、<strong>Entity間の親子関係をGUIで再構築可能</strong>。</li>
    <li>名前変更はInputTextを用いたインライン編集方式で、フォーカス制御も厳密。</li>
    <li><code>FlScene</code>と<code>CSDLLController</code>を連携させ、Prefab生成・インスタンス化などのScene管理操作を直接統合。</li>
  </ul>
</div>

    <div class="window-card">
      <h3>⚙️ InspectorWindow</h3>
      <p>
        選択されたEntityの情報とComponentを一覧表示。  
        追加・削除、各Componentの <code>RenderEditor()</code> によるUI描画もここで行われます。  
        何も選択していない場合は「No entity selected.」を表示します。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlInspectorAndHierarchyEditor::RenderInspector ---
if (auto sp = m_selectedEntity.lock())
{
    ImGui::Text("ID: %d", sp->id);
    ImGui::Separator();

    // 名前変更
    char nameBuffer[Def::BitMaskPos9];
    strncpy_s(nameBuffer, sizeof(nameBuffer), sp->name.c_str(), sizeof(nameBuffer) - Def::ULongLongOne);
    if (ImGui::InputText("Name", nameBuffer, sizeof(nameBuffer))) {
        sp->name = nameBuffer;
    }

    ImGui::SeparatorText("Components");

    // --- 各コンポーネントの描画 ---
    for (auto& comp : sp->components)
    {
        if (ImGui::CollapsingHeader(comp->GetType().c_str(), ImGuiTreeNodeFlags_DefaultOpen))
        {
            ImGui::Indent();
            comp->RenderImGui(); // Editor用の描画関数
            if (ImGui::Button(("Remove##" + comp->GetType()).c_str()))
                FlScene::Instance().DetachComponentLater(sp->id, comp->GetType());
            ImGui::Unindent();
        }
    }

    // --- コンポーネント追加 ---
    if (!attachableTypes.empty())
    {
        ImGui::Text("Add Component");
        static int selectedIndex = Def::IntZero;
        if (selectedIndex >= attachableTypes.size()) selectedIndex = Def::IntZero;
        if (ImGui::BeginCombo("##ComponentTypes", attachableTypes[selectedIndex]))
        {
            ...
        }
        ImGui::EndCombo();
        if (ImGui::Button("Attach"))
            FlScene::Instance().AttachComponent(sp->id, attachableTypes[selectedIndex]);
    }
}
else
    ImGui::Text("No entity selected.");
</code></pre>

<div class="concept-block">
  <h4>🧠 技術的ポイント</h4>
  <ul>
    <li>
      DLLControllerを通じて登録済みのコンポーネント型一覧を取得し、  
      アタッチ可能な種類をリアルタイムで抽出する <strong>型安全な拡張コンボボックス</strong>を実装。
    </li>
    <li>
      削除は即時反映ではなく<code>DetachComponentLater()</code>による <strong>安全な遅延破棄</strong>を採用。  
      更新中の参照切れを防ぎ、安定したエディタ挙動を保証。
    </li>
    <li>
      Componentの<code>RenderImGui()</code>を通じて、<strong>ランタイム組み込みエディタ</strong>として  
      同一コードベース内で動的編集を可能に。
    </li>
  </ul>
</div>

    <div class="window-card">
      <h3>🧮 FrameRateWindow</h3>
      <p>
        FPS・デルタタイム表示に加え、VSyncやLimitlessモード切替、  
        フレームレート上限を設定するスライダーを提供します。  
        パフォーマンスモニタとしても利用可能。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FrameRateWindow --- 
if (ImGui::Begin("FramesPerSecond"))
{
    if (auto spFrameRateController{ m_wpFrameRateController.lock() })
    {
        ImGui::Text("FPS : %f", spFrameRateController->GetCurrentFPS());
        ImGui::Text("DeltaTime : %f", spFrameRateController->GetDeltaTime());

        // VSync トグル
        if (ImGui::Checkbox("VSync", &spFrameRateController->WorkIsVsync()))
        {
            spFrameRateController->SetIsVsync(spFrameRateController->GetIsVsync());
            m_upLogEditor->AddLog("VSync: %s",
                spFrameRateController->GetIsVsync() ? "Enabled" : "Disabled");
        }

        ImGui::SameLine();

        // Limitless トグル
        if (ImGui::Checkbox("Limitless", &spFrameRateController->WorkIsLimitless()))
        {
            spFrameRateController->SetIsLimitless(spFrameRateController->GetIsLimitless());
            m_upLogEditor->AddLog("Limitless: %s",
                spFrameRateController->GetIsLimitless() ? "Enabled" : "Disabled");
        }

        // ターゲットFPS設定
        if (!spFrameRateController->GetIsLimitless())
        {
            ImGui::SliderInt("TargetFrameRate", &m_targetFrameRate, 30, 300);
            spFrameRateController->SetDesiredFPS(static_cast&lt;float&gt;(m_targetFrameRate));
        }
    }
}
ImGui::End();
</code></pre>

<div class="concept-block">
  <h4>⏱ 技術的ポイント</h4>
  <ul>
    <li>
      Limitlessモード切替により、<strong>ターゲットFPS制御を動的に解除・再設定</strong>可能。  
      シミュレーション／エディタ動作モードをシームレスに切替。
    </li>
    <li>
      スライダー値は <code>SetDesiredFPS()</code> を介して  
      エンジン全体の <strong>タイムステップ挙動</strong> に直接反映。  
      開発中でもリアルタイムに最適フレーム制御をテスト可能。
    </li>
  </ul>
</div>

    <div class="window-card">
      <h3>🎨 ThemeWindow</h3>
      <p>
        エディタ全体のテーマを変更。  
        トランジションはイージングを用いて自然に切り替わります。  
        ライト／ダークなどのテーマを即時反映。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlEditorCascadingStyleSheets::TransitionToTheme --- 
void FlEditorCascadingStyleSheets::TransitionToTheme(const std::string& name, double durationSec, FlAnimator::EaseFunc ease)
{
    if (m_themes.find(name) == m_themes.end()) return;
    m_targetTheme = name;
    m_animator = FlAnimator(durationSec, ease);
    m_animator.start();

    // 遷移開始時の状態をキャプチャ
    m_startStyle = ImGui::GetStyle();
}
</code></pre>

    <div class="concept-block">
  <h4>🎨 技術的ポイント</h4>
  <ul>
    <li>
      <strong>FlEditorCascadingStyleSheets</strong> クラスを中心に、<br>
      ImGuiの <code>ImGuiStyle</code> 構造体を直接制御することで  
      <strong>UIテーマ全体の統一的なスタイル管理</strong> を実現。
    </li>
    <li>
      テーマ定義は <code>m_themes</code> に保持され、  
      カラー (<code>ImVec4</code>)・パディング・ラウンディングなど  
      すべてのスタイル要素を構造体として記録。
    </li>
    <li>
      <code>ApplyTheme()</code> により即時切替、  
      <code>TransitionToTheme()</code> により  
      <strong>イージング関数付きのアニメーション遷移</strong>をサポート。  
      （内部では <code>FlAnimator</code> による補間が進行）
    </li>
    <li>
      <code>Update()</code> 関数では、各スタイル項目を  
      <code>lerp()</code> で補間し、自然なフェード演出を実現。  
      特に色（RGBA）の補間はImGuiカラー配列全体に反映。
    </li>
    <li>
      トランジション終了時に <code>m_currentTheme</code> を更新し、  
      不整合を防止する堅牢な状態遷移設計。  
      遷移中は <strong>ImGui::GetStyle()</strong> が動的に変化。
    </li>
    <li>
      この仕組みにより、ライト／ダークテーマ切替だけでなく  
      <strong>カスタムCSS的スタイル階層構造</strong>を実装可能。  
      UIデザインの一貫性と柔軟性を両立している。
    </li>
  </ul>
</div>

    <div class="window-card">
      <h3>🐍 PlugInWindow</h3>
      <p>
        特定フォルダ内のPythonスクリプトを自動検出。  
        各スクリプトに対応したボタンが生成され、クリックで実行可能。  
        出力は <strong>TerminalWindow</strong> に転送されます。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlPythonMacroEditor::ExecuteScript ---
std::string command = "python.exe \"" + std::filesystem::absolute(scriptPath).string() + "\"";
std::wstring wcommand = ansi_to_wide(command);

m_terminal.AddLog("> Executing: " + command);

if (!CreateProcess(nullptr, wcommand.data(), nullptr, nullptr, TRUE,
                   CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
{
    m_terminal.AddLog("> Error: Failed to start python.exe.");
    return;
}

CloseHandle(hWrite);
char buffer[4096];
DWORD read = 0;
while (ReadFile(hRead, buffer, sizeof(buffer) - 1, &read, nullptr) && read > 0)
{
    buffer[read] = '\0';
    m_terminal.AddLog(buffer); // 出力をリアルタイム転送
}

WaitForSingleObject(pi.hProcess, INFINITE);
CloseHandle(pi.hProcess);
CloseHandle(pi.hThread);
CloseHandle(hRead);
m_terminal.AddLog("> Script finished: " + scriptPath.filename().string());
</code></pre>

<div class="concept-block">
  <h4>🐍 技術的ポイント</h4>
  <ul>
    <li>
      <strong>FlPythonMacroEditor</strong> は  
      ランタイム中にPythonスクリプトを検出・実行し、出力を即時にTerminalWindowへ転送します。
    </li>
    <li>
      <code>std::filesystem</code> を利用して <strong>マクロフォルダを動的スキャン</strong>し、  
      拡張子 <code>.py</code> のみをUIボタンとして自動生成。  
      スクリプトを追加・削除しても <strong>再起動不要で即反映</strong>。
    </li>
    <li>
      実行プロセスは <code>CreateProcess()</code> により生成され、  
      標準出力／標準エラーを <code>CreatePipe()</code> でリダイレクト。  
      <strong>非同期でPython出力を読み取り、リアルタイムにFlTerminalEditorへ流す</strong>仕組み。
    </li>
  </ul>
</div>

    <div class="window-card">
      <h3>💻 TerminalWindow</h3>
      <p>
        PH-ECSエディタに統合された<strong>リアルタイム・コマンドライン環境</strong>。  
        ファイル操作・Git・Python・CMake・MSBuildなど、  
        あらゆる外部コマンドをエディタ内部から直接実行できます。  
        出力はすべてUTF-8整形され、リアルタイムにImGui上へストリーム表示されます。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlTerminalEditor::WorkerThread ---
while (m_running)
{
    std::string command;
    {
        std::unique_lock&lt;std::mutex&gt; lock(m_queueMutex);
        m_cv.wait(lock, [&] { return !m_running || !m_commandQueue.empty(); });
        if (!m_running) break;
        command = m_commandQueue.front();
        m_commandQueue.pop();
    }

    if (command.empty()) continue;

    // 内部コマンド処理 (cd, cls)
    if (command.rfind("cd ", 0) == 0)
    {
        std::string newDir = command.substr(3);
        auto newPath = m_currentDir / newDir;
        try {
            newPath = std::filesystem::canonical(newPath);
            if (std::filesystem::is_directory(newPath))
            {
                m_currentDir = newPath;
                AddLog("> Changed Current Directory: " + m_currentDir.string());
            }
            else AddLog("> Directory does not exist: " + newPath.string());
        }
        catch (const std::exception& e) {
            AddLog("> Directory change failed: " + std::string(e.what()));
        }
        continue;
    }

    // 外部プロセス実行 (例: git, python, cmake)
    SECURITY_ATTRIBUTES sa{ sizeof(SECURITY_ATTRIBUTES), nullptr, TRUE };
    HANDLE hRead = nullptr, hWrite = nullptr;
    CreatePipe(&hRead, &hWrite, &sa, 0);
    SetHandleInformation(hRead, HANDLE_FLAG_INHERIT, 0);

    STARTUPINFO si{ sizeof(STARTUPINFO) };
    PROCESS_INFORMATION pi{};
    si.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.hStdOutput = hWrite;
    si.hStdError  = hWrite;
    si.wShowWindow = SW_HIDE;

    auto fullCmd = "chcp 65001 > nul && cd /d \"" + m_currentDir.string() + "\" && " + command;
    auto wcmd = L"cmd.exe /c " + ansi_to_wide(fullCmd);

    if (!CreateProcess(nullptr, wcmd.data(), nullptr, nullptr, TRUE,
                       CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
    {
        AddLog("> Failed to execute command: " + command);
        continue;
    }

    CloseHandle(hWrite);
    AddLog("> " + m_currentDir.string() + " " + command);

    // --- リアルタイム出力 ---
    char buffer[4096];
    DWORD bytesRead = 0;
    while (ReadFile(hRead, buffer, sizeof(buffer) - 1, &bytesRead, nullptr) && bytesRead > 0)
    {
        buffer[bytesRead] = '\0';
        AddLog(std::string(buffer, bytesRead));
    }

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    CloseHandle(hRead);
    m_scrollToBottom = true;
}
</code></pre>

<div class="concept-block">
  <h4>💡 技術的ポイント</h4>
  <ul>
    <li>
      <strong>マルチスレッド構成</strong>：メインスレッドは描画専用、<code>WorkerThread()</code> はコマンド実行専用。  
      コマンド入力は <code>std::queue</code> と <code>std::condition_variable</code> によってスレッドセーフに非同期処理。
    </li>
    <li>
      <strong>プロセス生成と出力リダイレクト</strong>：  
      <code>CreatePipe()</code>＋<code>CreateProcess()</code> により、  
      標準出力／標準エラーを <code>ImGui</code> に転送。  
      外部ツール出力を <strong>リアルタイムストリーム</strong>として取得可能。
    </li>
    <li>
      <strong>内部コマンド</strong>（例: <code>cd</code>・<code>cls</code>）は  
      専用パスで直接実行し、外部プロセスを介さず高速反応。  
      <code>std::filesystem::canonical()</code> によるパス解決で安全性も確保。
    </li>
  </ul>
</div>



    <div class="window-card">
      <h3>🧱 DeveloperCommandPrompt</h3>
      <p>
        <strong>Visual Studio Developer Command Prompt</strong> をエディタ内で利用可能。  
        <code>msbuild</code>コマンドで任意プロジェクトのBuild / Cleanを実行できます。  
        バッチファイル経由で自動設定を行うため環境変数も維持されます。
      </p>
    </div>

<pre><code class="language-cpp">
// --- 抜粋: FlDeveloperCommandPromptEditor::Render ---
if (ImGui::Begin(title.c_str(), p_open, flags))
{
    // プロジェクト選択コンボ
    if (ImGui::BeginCombo("Project",
        m_selectedProject >= 0 ? m_parser.GetProjects()[m_selectedProject].name.c_str() : "Select"))
    {
        for (int i = 0; i &lt; m_parser.GetProjects().size(); i++) {
            bool selected = (m_selectedProject == i);
            if (ImGui::Selectable(m_parser.GetProjects()[i].name.c_str(), selected))
                m_selectedProject = i;
            if (selected) ImGui::SetItemDefaultFocus();
        }
        ImGui::EndCombo();
    }

    // 構成・プラットフォーム・アクション選択
    const char* configs[] = { "Debug", "Release" };
    const char* platforms[] = { "Win32", "x64" };
    const char* actions[] = { "Build", "Clean" };

    ImGui::Combo("Configuration", &m_selectedConfig, configs, IM_ARRAYSIZE(configs));
    ImGui::Combo("Platform", &m_selectedPlatform, platforms, IM_ARRAYSIZE(platforms));
    ImGui::Combo("Action", &m_selectedAction, actions, IM_ARRAYSIZE(actions));

    if (ImGui::Button("Execute")) {
        ExecuteBuild();
    }

    ImGui::Separator();
    RenderSystemMonitor(); // CPU / メモリ監視
}
ImGui::End();
</code></pre>

<pre><code class="language-cpp">
// --- 抜粋: FlDeveloperCommandPromptEditor::ExecuteBuild ---
if (m_selectedProject &lt; 0) {
    m_terminal.AddLog("No project selected.");
    return;
}

const auto& proj = m_parser.GetProjects()[m_selectedProject];
std::string config = (m_selectedConfig == 0) ? "Debug" : "Release";
std::string platform = (m_selectedPlatform == 0) ? "Win32" : "x64";
std::string action = (m_selectedAction == 0) ? "Build" : "Clean";

std::string solutionDir = std::filesystem::absolute(std::filesystem::current_path()).string() + "\\\\";

// vcvarsall.bat を呼び出し、環境変数付きでmsbuild実行
std::string command =
    "call \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" " +
    platform + " && msbuild \"" + proj.fullPath.string() +
    "\" /p:Configuration=" + config +
    " /p:Platform=" + platform +
    " /p:SolutionDir=\"" + solutionDir + "\"" +
    " /t:" + action;

m_terminal.ExecuteCommand(command.c_str());
</code></pre>

<pre><code class="language-cpp">
// --- 抜粋: FlDeveloperCommandPromptEditor::RenderSystemMonitor ---
cpuUsage = GetCpuUsage();
GetMemoryUsage(workingSet, peakWorkingSet);

if (m_upTicker-&gt;tick()) {
    cpuUsageTick = cpuUsage;
    threadList = GetThreadList();
}

ImGui::Text("CPU Usage: %.2f%%", cpuUsageTick);
ImGui::ProgressBar(static_cast&lt;float&gt;(cpuUsageTick / 100.0), ImVec2(0.0f, 0.0f));
ImGui::Separator();
ImGui::Text("Memory Usage: %.2f MB", workingSet / (1024.0 * 1024.0));
ImGui::Text("Peak Memory: %.2f MB", peakWorkingSet / (1024.0 * 1024.0));
ImGui::Text("Total Threads: %d", static_cast&lt;int&gt;(threadList.size()));
</code></pre>

<div class="concept-block">
  <h4>⚙️ 技術的ポイント</h4>
  <ul>
    <li>
      <strong>統合ビルド環境:</strong>  
      Visual Studio 付属の <code>vcvarsall.bat</code> を呼び出し、  
      <strong>環境変数やPATH設定を自動初期化</strong>したうえで  
      <code>msbuild</code> を安全に実行。  
      ビルド結果は <strong>FlTerminalEditor</strong> にリアルタイム転送。
    </li>
    <li>
      <strong>FlSolutionParser</strong> によって .sln 内のプロジェクト情報を解析。  
      複数プロジェクトを <strong>ImGui Combo UI</strong> で動的選択でき、  
      設定変更も即時反映。
    </li>
    <li>
      <strong>システムモニタ統合:</strong>  
      <code>PdhOpenQuery()</code> と <code>PdhAddCounter()</code> により  
      CPU 使用率をPDH APIで取得。  
      <code>GetProcessMemoryInfo()</code> で実行プロセスの  
      WorkingSet / Peakメモリを可視化。
    </li>
    <li>
      <strong>スレッド監視:</strong>  
      <code>CreateToolhelp32Snapshot()</code> と <code>Process32First()</code>  
      を使用して現在プロセスのスレッド一覧を走査。  
      各スレッドのCPU時間・優先度を <code>ImGui::Table</code> で整然表示。
    </li>
    <li>
      <strong>非同期ティッカー更新:</strong>  
      <code>FlChronus::Ticker()</code> を使用して  
      500msごとにCPU・スレッド情報を更新。  
      無駄なAPI呼び出しを避け、UIのスムーズさを維持。
    </li>
    <li>
      <strong>Terminalとの連携:</strong>  
      実際のビルドログは <code>FlTerminalEditor</code> 経由で  
      ImGui上にリアルタイム出力。  
      成功／失敗の状態が即座に視覚化される。
    </li>
    <li>
      <strong>実運用志向の設計:</strong>  
      Release/Debug・Win32/x64の切り替えや、  
      複数プロジェクト管理に対応。  
      外部シェルを使わず、<strong>完全統合されたIDE環境</strong>を構築。
    </li>
  </ul>
</div>

<div class="window-card">
  <h3>🪶 LogWindow</h3>
  <p>
    各エディタモジュールやシステムイベントのログを収集し、  
    カラー付きで視覚的に区別された形式で表示します。  
    <strong>Copy / Export / Font Scaling</strong> による利便性の高い操作が可能で、  
    実行中のランタイム挙動をリアルタイムに追跡できます。
  </p>
</div>

<pre><code class="language-cpp">
// --- 抜粋: FlLogEditor::RenderLog ---
ImGui::Begin(title.c_str(), p_opened, flags);

if (ImGui::Button("Clear")) Clear();
ImGui::SameLine();
if (ImGui::Button("Copy")) Copy();
ImGui::SameLine();
if (ImGui::Button("Export")) ExportLog();
ImGui::SameLine();
ImGui::InputText(".log  Export File Path", &m_exportPath);

ImGui::Separator();

// --- フォントスケーリング制御 ---
ImGui::Text("Font Size:");
ImGui::SameLine();
if (ImGui::Button("-##FontDown")) m_fontScale = std::max(m_fontScale - 0.1f, m_minFontScale);
ImGui::SameLine();
if (ImGui::Button("+##FontUp")) m_fontScale = std::min(m_fontScale + 0.1f, m_maxFontScale);
ImGui::SameLine();
ImGui::SliderFloat("##FontScale", &m_fontScale, m_minFontScale, m_maxFontScale, "%.1fx");
ImGui::SameLine();
if (ImGui::Button("Reset##FontReset")) ResetFontScale();

ImGui::Separator();
ImGui::BeginChild("LogScroll", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);

// --- ログの描画 ---
for (const auto& entry : m_logEntries)
{
    const auto color = ImVec4(entry.color.R(), entry.color.G(), entry.color.B(), entry.color.A());
    ImGui::PushStyleColor(ImGuiCol_Text, color);
    ImGui::TextUnformatted(entry.text.c_str());
    ImGui::PopStyleColor();
}

if (m_scrollToBottom) ImGui::SetScrollHereY(1.0f);
ImGui::EndChild();

ImGui::End();
</code></pre>

<pre><code class="language-cpp">
// --- 抜粋: FlLogEditor::ExportLog ---
if (m_logEntries.empty()) {
    AddWarningLog("Warning: Log is empty: Nothing to export");
    return;
}

if (m_exportPath.empty()) {
    AddErrorLog("Error: Export path cannot be empty");
    return;
}

auto path = m_exportPath + ".log";
auto upDebLogger = std::make_unique&lt;DebugLogger&gt;(path);

for (const auto& logText : m_logEntries)
    DEBUG_LOG(upDebLogger, logText.text.c_str());

DEBUG_LOG(upDebLogger, "-------------------------------------------");

if (!upDebLogger-&gt;IsOpen())
    AddErrorLog("Error: Could not open log file %s", path.c_str());
else
    AddSuccessLog("Export successful: Path %s", path.c_str());
</code></pre>

<div class="concept-block">
  <h4>🪶 技術的ポイント</h4>
  <ul>
    <li>
      <strong>動的フォントスケーリング:</strong>  
      <code>io.FontGlobalScale</code> と <code>style.ScaleAllSizes()</code> を組み合わせ、  
      ImGuiスタイル全体をリアルタイムでスケーリング。  
      ログビューアとしての可読性を自由に調整可能。
    </li>
    <li>
      <strong>カラーログ設計:</strong>  
      ログエントリごとにRGBAカラーを保持し、<br>
      <code>PushStyleColor(ImGuiCol_Text, color)</code> で出力。  
      通常ログ・警告・エラー・成功を色で明確に分類。
    </li>
    <li>
      <strong>安全なエクスポート機構:</strong>  
      出力先パスの存在チェックを行い、空や未指定の場合は  
      <code>AddErrorLog()</code> によりユーザーへ警告を出力。  
      <code>DebugLogger</code> 経由で <code>.log</code> ファイルを生成。
    </li>
    <li>
      <strong>クリップボード連携:</strong>  
      <code>ImGui::LogToClipboard()</code> により、  
      現在のログをワンクリックでコピー。  
      コンソール出力やサポート報告にも即利用可能。
    </li>
    <li>
      <strong>リアルタイム更新最適化:</strong>  
      <code>m_scrollToBottom</code> を制御して  
      新規ログ追加時のみスクロールを末尾へ自動移動。  
      長大ログでも無駄な再描画を抑制。
    </li>
    <li>
      <strong>高拡張性:</strong>  
      <code>AddSuccessLog()</code>, <code>AddWarningLog()</code>, <code>AddErrorLog()</code>  
      といったヘルパー関数を通じて、他エディタから統一フォーマットで呼び出し可能。  
      システム全体のイベント追跡に統合的役割を果たす。
    </li>
  </ul>
</div>

</section>

<section id="navigation" class="section">
  <h2>Next Pages</h2>
  <p>さらにPH-ECSの詳細な技術資料・設計思想を以下で解説しています。</p>

  <ul class="toc">
    <li><a href="architecture.html">◀ Architecture – 内部構造とデータフロー</a></li>
    <li><a href="support.html">▶ Support – 各開発支援機能</a></li>
    <li><a href="developer.html">▶ Developer – 開発者コメント</a></li>
    <li><a href="index.html">◀ Back to Top – トップページへ戻る</a></li>
  </ul>
</section>

<footer class="footer">
  <p>© 2025 Falcon Engine Project – Pragmatic Hybrid ECS</p>
</footer>

</body>
</html>